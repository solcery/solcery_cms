TODO:

BrickTree to string


Карты без экшенов - проверить что работают
Юнити-фрейм
ошибка на выполнении механики
ошибка на выполнении транзации?
Генерировать cardType
фильтр по enabled


util.get
редирект обратно на сохранении
нули


dictionary

Copy project
Pubkey type
Victory state
remove place attr
create card on join
better UI


Initializer for slots


Filter by field
UNITY - art override


Iterator



Player в GameState

GlobalVars?





Game/Forge



Backlog:



Nested templates (arrays)


Project full unconstructed content model?
Prohibit arg usage in cards
Fix typedata usage and compilation problems
Construct
Raw storage view
Singleton template
String bricktree
Field description
TypeSelector Type?
GetName for module



mech
Any
Aggr



Слот:


Playerslots:

Что делать для двоих придумаем

Place //TODO: playerIndex
Collections
Default


Мы спрашиваем игрока 


Collections
updateAut
validatedCreator
SYMB




Badgers: updateAuthority+creator = "TESAinbTL2eBLkWqyGA82y1RS6kArHvuYWfkL9dKkbs" "BBS"

BAES: creator 65jMEhVzEimJbcunsvr8wvD8VkSnUiu7zZU6pqm7v29p, update = EbR4788Gi79GwcT8cANSq4aDHoxD7XrQVGgCfUiML2wX "Metabaes"

The Sneks: creator AuTF3kgAyBzsfjGcNABTSzzXK4bVcZcyZJtpCrayxoVp symbol="" update = DYWwMTH4J8Xr7qvpTjiQBjFbAqrDaHvdGqrhriLRrzxz

Bears: update = "8749adNqCXzVjdYVCUFcjUUxsPcHuCW482roGqsxtMRX", "BEAR"

SMB: symbol = "SMB", update = 9uBX3ASjxWvNBAD1xjbVaKA74mWGZys3RGSF7DdeDD3F

DAPE: symbol = "DAPE" update+creator = DC2mkgwhy56w3viNtHDjJQmc7SGu2QX785bS4aexojwX

create project


==================

use admin as protocol - BorshSchema


===================



Template forge

Collection




Hey! Everything's fine - pacing forward with the development and the hackathon submission. 

Can't say we're working directly with Tommy, we had a nice call and discussed possible future of game-oriented NFTs on Solana. We had a meeting with Metaplex focused on the same topic too. We decided that the best way to showcase our standard it to use it in Solcery, so there aren't any particular collaboration plans yet


=================



SolceryMatchmaking


CreateRoom

 
JoinRoom //
SetReady

Room: {
	max_
	last_update: u64 // timestamp 
	members: Vec<PublicKey>
}





У нас уже есть стейт-аккаунт, он принадлежит гейму и захардкожен (пока что)


Конструируем и сериализуем стейт




Есть фрейм, он умеет получать игровой стейт и контент





Игровой фрейм это компонент. В него можно вгрузить контент и можно засетить гейм. Когда обе эти штуки есть - грузится юнити




Этот фрейм умеет вызывать onUseCard




Если нет плеерстейта - паника, потом поведение для пустой игры
Если в плеерстейте пустая игра - показываем кнопку "создать игру", по которой:

создаем все нужные аккаунты и вызываем creategame




Мы заходим и видим в плеерстейте непустую игру.

Получаем информацию про эту игру.


project - это контент, скачиваем его -> собираем контент

также скачиваем и десериализуем стейт. -> собираем


когда и то и то готово -> по очереди отправляем в юнити




Когда в юнити


По юнити плейкард отправляем новый стейт


{"CardTypes":[{"Id":8,"BrickTree":{},"Metadata":{"PictureUrl":"https://arweave.net/5-L71209IxVqlr_QANYz9MjniPWTOm1DFg7NRw7UR0w","Name":"Degen Ape","Description":"Moves to another place"}}],"DisplayData":{"PlaceDisplayDatas":[{"PlaceName":"Bottom","PlaceId":1,"AreCardsInteractableIfMeIsActive":true,"IsVisible":true,"HorizontalAnchors":{"Min":0.1,"Max":0.9},"VerticalAnchors":{"Min":0.1,"Max":0.3},"CardFaceOption":1,"CardLayoutOption":1},{"PlaceName":"Top","PlaceId":2,"AreCardsInteractableIfMeIsActive":true,"IsVisible":true,"HorizontalAnchors":{"Min":0.1,"Max":0.9},"VerticalAnchors":{"Min":0.7,"Max":0.9},"CardFaceOption":1,"CardLayoutOption":1}]}}
index.tsx:85 {"LastUpdate":1633568441123,"Players":[{"Address":"None","IsActive":true,"HP":25,"Coins":0,"IsMe":true,"Attrs":[0,0,0,0,0,0,0,0,0,0]},{"Address":"None","IsActive":false,"HP":25,"Coins":0,"IsMe":false,"Attrs":[0,0,0,0,0,0,0,0,0,0]}],"Cards":[{"CardId":0,"CardType":8,"CardPlace":1},{"CardId":1,"CardType":8,"CardPlace":1},{"CardId":2,"CardType":8,"CardPlace":1}],"Message":{"Nonce":1,"Message":"No message","Duration":5},"Random":{"x":1,"y":2,"z":3,"w":4},"EndTurnCardId":5}

{"CardTypes":[{"Id":8,"BrickTree":{},"Metadata":{"PictureUrl":"https://arweave.net/5-L71209IxVqlr_QANYz9MjniPWTOm1DFg7NRw7UR0w","Name":"Degen Ape","Description":"Moves to another place"}}],"DisplayData":{"PlaceDisplayDatas":[{"PlaceName":"Bottom","PlaceId":1,"AreCardsInteractableIfMeIsActive":true,"IsVisible":true,"HorizontalAnchors":{"Min":0.1,"Max":0.9},"VerticalAnchors":{"Min":0.1,"Max":0.3},"CardFaceOption":1,"CardLayoutOption":1},{"PlaceName":"Top","PlaceId":2,"AreCardsInteractableIfMeIsActive":true,"IsVisible":true,"HorizontalAnchors":{"Min":0.1,"Max":0.9},"VerticalAnchors":{"Min":0.7,"Max":0.9},"CardFaceOption":1,"CardLayoutOption":1}]}}
index.tsx:85 {"LastUpdate":1633568489328,"Players":[{"Address":"None","IsActive":true,"HP":25,"Coins":0,"IsMe":true,"Attrs":[0,0,0,0,0,0,0,0,0,0]},{"Address":"None","IsActive":false,"HP":25,"Coins":0,"IsMe":false,"Attrs":[0,0,0,0,0,0,0,0,0,0]}],"Cards":[{"CardId":1,"CardType":8,"CardPlace":1},{"CardId":2,"CardType":8,"CardPlace":1},{"CardId":3,"CardType":8,"CardPlace":1}],"Message":{"Nonce":1,"Message":"No message","Duration":5},"Random":{"x":1,"y":2,"z":3,"w":4},"EndTurnCardId":5}


import { HomeView, TemplateView, AccountView, TemplateSchemaView, ObjectView, PlayView, GameView } from "./views";
export function Routes() {
  return (
    <>
      <HashRouter basename={"/"}>
        <ConnectionProvider>
          <WalletProvider>
            <Switch>
              <Route exact path="/account" component={() => <AccountView/>} />
              <Route exact path="/game/:gameId" component={() => <GameView />} />
              <Route path="/account/:accountKey" component={() => <AccountView/>} />
              <Route path ="/" component={() => 
                <ProjectProvider> 
                  <AccountsProvider>
                    <AppLayout>
                      <Switch>
                        <Route exact path="/play" component={() => <PlayView/>} />
                        <Route exact path="/template/:templateKey" component={() => <TemplateView/>} />
                        <Route path="/object/:objectId" component={() => <ObjectView/>} />
                        <Route path="/template/schema/:templateKey" component={() => <TemplateSchemaView/>} />
                        <Route exact path="/" component={() => <HomeView />} />
                      </Switch>
                    </AppLayout>
                  </AccountsProvider>
                </ProjectProvider>}
              />
            </Switch>
          </WalletProvider>
        </ConnectionProvider>
      </HashRouter>
    </>
  );
}


Game from Content что делает


Собирает все кардтайпы в одну кучу


Для каждого из слотов создаем геймобжект с tplId ведущим на Slots и дефолтным id в порядке очередности.

Когда игрок джойнится, мы смотрим, какой по очередности это игрок и берем все слоты с этим номером. Известно что на момент взятия для каждого из слотов есть ровно один геймобжект с его tplId, получаем массив tplId и геймобъектов.


Предлагаем в реакте собрать массив пар [ gameObjectId, mintAccountPubkey ]. 
Когда собрали - всем выделенным геймобъектам проставляем правильный tplId, он указан на коллекции и мы по нему фильтровали.
Всем невыделенным тоже проставляем default. Отправляем массив пар и новый игровой стейт.


Имея игру и стейт можем собрать инфу для клиента. Для этого для каждого игрока пробегаем по его собственности и видим массив пар 
[ gameObjectId, mintAccountPubkey ]. Для каждого такого объекта создаем фейковый темплейт для клиента, в который подставляем метадату в картинку.





Начать собирать игру - что-то достаточно простое


Что даем прогерам?
Кто настроит слак и почты?


Когда будет лендинг?
Когда напишем сабмишен?
Какой сюжет у видюшки, как будем собирать?




10 утра субботы - дедлайн






Пн


Вт

Какая-то базовая версия игры
Видюхи для лендинга - превизы


Ср


Чт

Финальный лендинг без видео

Пт

Пишем видюшки на лендинг
Все готово



Есть адмиинка в вебе. Считается, что она умеет описывать любые необходимые нам структуры данных. Блокчейн их хранит, веб-морда умеет загружать и десериализовать в нормальый вид, например json.
Важным типом данных, сериализуемым в нашем мире, будут являться BrickTree (название техническое, можно придумать получше)

------

Про BrickTree

BrickTree это некий язык, которым пользователи Solcery будут описывать разные поведения. Каждый узел - это функция, которая замаплена на какую-то функцию в интерпретаторе, в нашем случае в C#. Функции бриков в качестве единственного аргумента принимают Context - таблицу определенного формата. То что сейчас написано в Runtime -  довольно близкое к тому, что требуется. 

На этих бриктришках будет собираться и игровая логика для бэкенда и какие-то клиентские сценарии (проиграть звук, нарисовать партикл/трейл). Эти бриктришки умеют, в числе прочего, получать доступ к какому-то игровому состоянию.

-----

Игра - это юнити-клиент, собранный для веба. Этот клиент получает от среды три куска данных Content, State, Resources

--------

Content - это список всех статических сущностей, о которых необходимо знать клиенту игры. Строго говоря, контент не регламентирован и он собирается админкой с помощью некой инструкции. Считается, что контент не умеет обновляться динамически. Админка генерит json с контентом, он, в свою очередь десериализуется в какие-то структуры в памяти приложения.


Например, текущий контент выглядит так:
public class GameContent
{
    public BoardDisplayData DisplayData;
    public List<BoardCardType> CardTypes;
}

CardTypes - структура, содержащая картинку, название и описание типа карты и все необходимые статические поля, описывающие класс игрового объекта Card, а тай же айдишник этого типа.

DisplayData - это синтетический контент, который описывает рендер игрового экрана. Пока что считали, что все наши игры не имеют каких-то переходов между сценами и о них удобно мыслить как о цифровых настолках. На текущее состояние DisplayData смотреть не нужно, там совсем хардкод.

Считается, что рендер игры состоит из виджетов. Это нечто, имеющее определенное положение на экране, какой-то задаваемый внеший вид, и умение реагировать на обновление игрового состояния. Программироваться виджеты должны на бриках.

Например, виджетом является прямоугольник, который рендерит в ряд все карты, имеющие атрибут place, равный 1, и позволяющий кликать на эти карты.
Другой вариант виджета - кнопка End Turn в правом нижнем углу, видимая только текущему активному игроку и завершающая текущий ход.
Бар хп снизу экрана, показывающий атрибут hp у конкретной карты - еще один тип виджета.


Пользователи не собирают типы виджетов, они используют предложенные нами и конфигурируют их. Например для виджета, который показывает картинку и число на ней, пользователь может выбрать, собственно, картинку, размер числа и способ получить это число из игровых данных.



------------


State - это регламентированное состояние игры. На данный момент считается, что все состояние игры описывается с помощью подобной структуры:

GameState {
  objects: GameObject[],
  players: Player[],
  attrs: Map (string -> u32),
}
GameObject {
  id: u32,
  templateId: u32,
  attrs: Map (string -> i32), 
}
Player {
  id: u32,
  attrs: Map (string -> i32), 
}


Ради простоты удобно считать, что мы ТОЛЬКО про карточки и называть GameObject'ы картами. Но надо понимать, что в нашем случае чем абстрактнее мы пишем, тем меньше потом пуль из ноги достаем, лучше сразу делать общо.

--------

Resources
Это самый простой в описании блок данных, некий манифест о том, какие бандлы/ресурсы надо скачивать для данной конкретной игры. Считается, что его в каком-то виде будет генерить админка. Юнити клиент должен уметь скачивать и кэшировать все необходимые ресусрсы.

  
--------

Клиент позволяет как-то взаимодействовать с виджетами - можно нажимать на кнопки, использовать карты. Когда юзер выполняет действие, которое касается игровой механики, клиент отправляет это действие (например, каст карты) в виде JSON на фронтенд. Тот преобразует это в транзакцию, подписывает ее с помощью юзера и отправляет в чейн. Когда чейн применит изменения к аккаунту игрового состояния, фронт получит изменения, сериализует игровое состояние в json и вызовет обновлении у юнити-фрейма




Рантайм для механики



GameState

GameObject {
  id: u32,
  templateId: u32,
  attrs: Map (string -> i32), 
}

GameContent {
  CardTypes
}


GameContent


GameContent





Challenges we ran into

Трудно онбордить новых сотрудников. Порог входа в блокчейн высокий. Иногда приходится объяснять что блокчейн это добро и будущее, иногда долго объяснять что вообще происходит. 

- Солана предоставляет очень быстрый, но при этом очень ограниченный в разных смыслах рантайм. Каждое из ее ограничений так или иначе требовало внимания.
- Максимальный размер транзакции был побежден с помощью компиляции. Все, необходимое рантайму, подготавливаем заранее.
- Ограничение на количество вычислений для одной транзакции - побороли с помощью виртуальной машины, которая умеет быстро сериализоваться и становиться на паузу.
- Один из наших продуктов - база данных. Невозможность за раз пройтись по всем ее аккаунтам полечили с помощью: а) изобретение избыточного, но бесконечно обратно-совместимого формата данных и б) представлением базы данных в виде, в достаточной степени удобном для VM.
- Отсутствие игровых разработчиков. Общаясь с другими командами, мы видели очень много людей, пришедших в крипто-игры из крипты и очень мало, пришедших из геймдева. Это сделало дискуссии довольно однобокими.


Accomplishments that we're proud of

В целом все хорошее, что мы сделали - мы сделали в рамках решения каких-то значимых проблем. Из общих достижений
Изобрели стандарт для NFT, который станет будущим и, по нашему мнению, может устроить революцию не только в NFT, а в игровой индустрии в целом.
Одни из первых собрали реально рабочую игру на Solana, хоть и простенькую.
Придумали и спроектировали схему governance для Solcery, которая позволит пользователям управлять протоколами, оперируя теми же инструментами, которые используются для разработки игр.


What we learned

RUST - замечательный и очень крутой язык.
Unity плохо подходит для веба.
Очень легко добиться инвестиций и очень трудно их легализовать.


Challenges we ran into

-It is difficult to recruit new employees for blockchain development. The entry threshold into blockchain is pretty high.
- Solana provides a rapid runtime, but also strictly limited in many ways. Each of its limitations required attention in one way or another. 
- The maximum transaction size has been defeated by compilation and batching. Everything that's necessary for protocols should be prepared in advance.
- The limit on the number of calculations for one transaction was worked around with a virtual machine that is able to suspend it's work and effectively serialize it's state into Solana account.
- One of our products is a database. The inability to go through all of its accounts at once was cured by a) inventing a redundant but infinitely backward-compatible data format and b) representing the database in a way that is VM-friendly, which will allow to program and perform database scripts and migrations with user-friendly node editor.
- Lack of game developers in the ecosystem. Talking to other teams, we saw a lot of people coming into cryptogames from defi and trading and very few coming from gamedev. This has made the discussions rather one-sided.


Accomplishments that we're proud of

Basically, all the good things we've done - we've done solving some problem. Of the general achievements.
Invented a standard for the NFT that would become the future, and in our opinion, could revolutionize not just the NFT, but the gaming industry as a whole.
We were one of the first to build a working game on Solana, even if it's very simple.
We invented and designed governance for Solcery, which would allow users to operate protocols using the same tools that are used for game development.


What we learned

RUST is a great and very cool language.
Unity is not well suited to the web.
Very easy to get investment and very hard to legalise.

Translated with www.DeepL.com/Translator (free version)