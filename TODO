TODO:

Создание playerState добавить в гейм

create account state
BrickTree to string


фильтр для плей мода
card names in play mode


Карты без экшенов - проверить что работают
Убрать кнопку send из play
Юнити-фрейм
ошибка на выполнении механики
ошибка на выполнении транзации?
Генерировать cardType
фильтр по enabled


util.get
редирект обратно на сохранении
нули




dictionary

Copy project
Pubkey type
Victory state
remove place attr
create card on join
better UI


Initializer for slots


Filter by field
UNITY - art override


Iterator



Player в GameState

GlobalVars?





Game/Forge



Backlog:



Nested templates (arrays)


Project full unconstructed content model?
Prohibit arg usage in cards
Fix typedata usage and compilation problems
Construct
Raw storage view
Singleton template
String bricktree
Field description
TypeSelector Type?
GetName for module



mech
Any
Aggr



Слот:


Playerslots:

Что делать для двоих придумаем

Place //TODO: playerIndex
Collections
Default


Мы спрашиваем игрока 


Collections
updateAut
validatedCreator
SYMB




Badgers: updateAuthority+creator = "TESAinbTL2eBLkWqyGA82y1RS6kArHvuYWfkL9dKkbs" "BBS"

BAES: creator 65jMEhVzEimJbcunsvr8wvD8VkSnUiu7zZU6pqm7v29p, update = EbR4788Gi79GwcT8cANSq4aDHoxD7XrQVGgCfUiML2wX "Metabaes"

The Sneks: creator AuTF3kgAyBzsfjGcNABTSzzXK4bVcZcyZJtpCrayxoVp symbol="" update = DYWwMTH4J8Xr7qvpTjiQBjFbAqrDaHvdGqrhriLRrzxz

Bears: update = "8749adNqCXzVjdYVCUFcjUUxsPcHuCW482roGqsxtMRX", "BEAR"

SMB: symbol = "SMB", update = 9uBX3ASjxWvNBAD1xjbVaKA74mWGZys3RGSF7DdeDD3F

DAPE: symbol = "DAPE" update+creator = DC2mkgwhy56w3viNtHDjJQmc7SGu2QX785bS4aexojwX

create project


==================

use admin as protocol - BorshSchema


===================



Template forge

Collection




Hey! Everything's fine - pacing forward with the development and the hackathon submission. 

Can't say we're working directly with Tommy, we had a nice call and discussed possible future of game-oriented NFTs on Solana. We had a meeting with Metaplex focused on the same topic too. We decided that the best way to showcase our standard it to use it in Solcery, so there aren't any particular collaboration plans yet


=================



SolceryMatchmaking


CreateRoom

 
JoinRoom //
SetReady

Room: {
	max_
	last_update: u64 // timestamp 
	members: Vec<PublicKey>
}





У нас уже есть стейт-аккаунт, он принадлежит гейму и захардкожен (пока что)


Конструируем и сериализуем стейт




Есть фрейм, он умеет получать игровой стейт и контент





Игровой фрейм это компонент. В него можно вгрузить контент и можно засетить гейм. Когда обе эти штуки есть - грузится юнити




Этот фрейм умеет вызывать onUseCard




Если нет плеерстейта - паника, потом поведение для пустой игры
Если в плеерстейте пустая игра - показываем кнопку "создать игру", по которой:

создаем все нужные аккаунты и вызываем creategame




Мы заходим и видим в плеерстейте непустую игру.

Получаем информацию про эту игру.


project - это контент, скачиваем его -> собираем контент

также скачиваем и десериализуем стейт. -> собираем


когда и то и то готово -> по очереди отправляем в юнити




Когда в юнити


По юнити плейкард отправляем новый стейт


{"CardTypes":[{"Id":8,"BrickTree":{},"Metadata":{"PictureUrl":"https://arweave.net/5-L71209IxVqlr_QANYz9MjniPWTOm1DFg7NRw7UR0w","Name":"Degen Ape","Description":"Moves to another place"}}],"DisplayData":{"PlaceDisplayDatas":[{"PlaceName":"Bottom","PlaceId":1,"AreCardsInteractableIfMeIsActive":true,"IsVisible":true,"HorizontalAnchors":{"Min":0.1,"Max":0.9},"VerticalAnchors":{"Min":0.1,"Max":0.3},"CardFaceOption":1,"CardLayoutOption":1},{"PlaceName":"Top","PlaceId":2,"AreCardsInteractableIfMeIsActive":true,"IsVisible":true,"HorizontalAnchors":{"Min":0.1,"Max":0.9},"VerticalAnchors":{"Min":0.7,"Max":0.9},"CardFaceOption":1,"CardLayoutOption":1}]}}
index.tsx:85 {"LastUpdate":1633568441123,"Players":[{"Address":"None","IsActive":true,"HP":25,"Coins":0,"IsMe":true,"Attrs":[0,0,0,0,0,0,0,0,0,0]},{"Address":"None","IsActive":false,"HP":25,"Coins":0,"IsMe":false,"Attrs":[0,0,0,0,0,0,0,0,0,0]}],"Cards":[{"CardId":0,"CardType":8,"CardPlace":1},{"CardId":1,"CardType":8,"CardPlace":1},{"CardId":2,"CardType":8,"CardPlace":1}],"Message":{"Nonce":1,"Message":"No message","Duration":5},"Random":{"x":1,"y":2,"z":3,"w":4},"EndTurnCardId":5}

{"CardTypes":[{"Id":8,"BrickTree":{},"Metadata":{"PictureUrl":"https://arweave.net/5-L71209IxVqlr_QANYz9MjniPWTOm1DFg7NRw7UR0w","Name":"Degen Ape","Description":"Moves to another place"}}],"DisplayData":{"PlaceDisplayDatas":[{"PlaceName":"Bottom","PlaceId":1,"AreCardsInteractableIfMeIsActive":true,"IsVisible":true,"HorizontalAnchors":{"Min":0.1,"Max":0.9},"VerticalAnchors":{"Min":0.1,"Max":0.3},"CardFaceOption":1,"CardLayoutOption":1},{"PlaceName":"Top","PlaceId":2,"AreCardsInteractableIfMeIsActive":true,"IsVisible":true,"HorizontalAnchors":{"Min":0.1,"Max":0.9},"VerticalAnchors":{"Min":0.7,"Max":0.9},"CardFaceOption":1,"CardLayoutOption":1}]}}
index.tsx:85 {"LastUpdate":1633568489328,"Players":[{"Address":"None","IsActive":true,"HP":25,"Coins":0,"IsMe":true,"Attrs":[0,0,0,0,0,0,0,0,0,0]},{"Address":"None","IsActive":false,"HP":25,"Coins":0,"IsMe":false,"Attrs":[0,0,0,0,0,0,0,0,0,0]}],"Cards":[{"CardId":1,"CardType":8,"CardPlace":1},{"CardId":2,"CardType":8,"CardPlace":1},{"CardId":3,"CardType":8,"CardPlace":1}],"Message":{"Nonce":1,"Message":"No message","Duration":5},"Random":{"x":1,"y":2,"z":3,"w":4},"EndTurnCardId":5}


import { HomeView, TemplateView, AccountView, TemplateSchemaView, ObjectView, PlayView, GameView } from "./views";
export function Routes() {
  return (
    <>
      <HashRouter basename={"/"}>
        <ConnectionProvider>
          <WalletProvider>
            <Switch>
              <Route exact path="/account" component={() => <AccountView/>} />
              <Route exact path="/game/:gameId" component={() => <GameView />} />
              <Route path="/account/:accountKey" component={() => <AccountView/>} />
              <Route path ="/" component={() => 
                <ProjectProvider> 
                  <AccountsProvider>
                    <AppLayout>
                      <Switch>
                        <Route exact path="/play" component={() => <PlayView/>} />
                        <Route exact path="/template/:templateKey" component={() => <TemplateView/>} />
                        <Route path="/object/:objectId" component={() => <ObjectView/>} />
                        <Route path="/template/schema/:templateKey" component={() => <TemplateSchemaView/>} />
                        <Route exact path="/" component={() => <HomeView />} />
                      </Switch>
                    </AppLayout>
                  </AccountsProvider>
                </ProjectProvider>}
              />
            </Switch>
          </WalletProvider>
        </ConnectionProvider>
      </HashRouter>
    </>
  );
}


Game from Content что делает


Собирает все кардтайпы в одну кучу


Для каждого из слотов создаем геймобжект с tplId ведущим на Slots и дефолтным id в порядке очередности.

Когда игрок джойнится, мы смотрим, какой по очередности это игрок и берем все слоты с этим номером. Известно что на момент взятия для каждого из слотов есть ровно один геймобжект с его tplId, получаем массив tplId и геймобъектов.


Предлагаем в реакте собрать массив пар [ gameObjectId, mintAccountPubkey ]. 
Когда собрали - всем выделенным геймобъектам проставляем правильный tplId, он указан на коллекции и мы по нему фильтровали.
Всем невыделенным тоже проставляем default. Отправляем массив пар и новый игровой стейт.


Имея игру и стейт можем собрать инфу для клиента. Для этого для каждого игрока пробегаем по его собственности и видим массив пар 
[ gameObjectId, mintAccountPubkey ]. Для каждого такого объекта создаем фейковый темплейт для клиента, в который подставляем метадату в картинку.





Начать собирать игру - что-то достаточно простое


Что даем прогерам?
Кто настроит слак и почты?


Когда будет лендинг?
Когда напишем сабмишен?
Какой сюжет у видюшки, как будем собирать?




10 утра субботы - дедлайн






Пн


Вт

Какая-то базовая версия игры
Видюхи для лендинга - превизы


Ср


Чт

Финальный лендинг без видео

Пт

Пишем видюшки на лендинг
Все готово



Есть адмиинка в вебе. Считается, что она умеет описывать любые необходимые нам структуры данных. Блокчейн их хранит, веб-морда умеет загружать и десериализовать в нормальый вид, например json.
Важным типом данных, сериализуемым в нашем мире, будут являться BrickTree (название техническое, можно придумать получше)

------

Про BrickTree

BrickTree это некий язык, которым пользователи Solcery будут описывать разные поведения. Каждый узел - это функция, которая замаплена на какую-то функцию в интерпретаторе, в нашем случае в C#. Функции бриков в качестве единственного аргумента принимают Context - таблицу определенного формата. То что сейчас написано в Runtime -  довольно близкое к тому, что требуется. 

На этих бриктришках будет собираться и игровая логика для бэкенда и какие-то клиентские сценарии (проиграть звук, нарисовать партикл/трейл). Эти бриктришки умеют, в числе прочего, получать доступ к какому-то игровому состоянию.

-----

Игра - это юнити-клиент, собранный для веба. Этот клиент получает от среды три куска данных Content, State, Resources

--------

Content - это список всех статических сущностей, о которых необходимо знать клиенту игры. Строго говоря, контент не регламентирован и он собирается админкой с помощью некой инструкции. Считается, что контент не умеет обновляться динамически. Админка генерит json с контентом, он, в свою очередь десериализуется в какие-то структуры в памяти приложения.


Например, текущий контент выглядит так:
public class GameContent
{
    public BoardDisplayData DisplayData;
    public List<BoardCardType> CardTypes;
}

CardTypes - структура, содержащая картинку, название и описание типа карты и все необходимые статические поля, описывающие класс игрового объекта Card, а тай же айдишник этого типа.

DisplayData - это синтетический контент, который описывает рендер игрового экрана. Пока что считали, что все наши игры не имеют каких-то переходов между сценами и о них удобно мыслить как о цифровых настолках. На текущее состояние DisplayData смотреть не нужно, там совсем хардкод.

Считается, что рендер игры состоит из виджетов. Это нечто, имеющее определенное положение на экране, какой-то задаваемый внеший вид, и умение реагировать на обновление игрового состояния. Программироваться виджеты должны на бриках.

Например, виджетом является прямоугольник, который рендерит в ряд все карты, имеющие атрибут place, равный 1, и позволяющий кликать на эти карты.
Другой вариант виджета - кнопка End Turn в правом нижнем углу, видимая только текущему активному игроку и завершающая текущий ход.
Бар хп снизу экрана, показывающий атрибут hp у конкретной карты - еще один тип виджета.


Пользователи не собирают типы виджетов, они используют предложенные нами и конфигурируют их. Например для виджета, который показывает картинку и число на ней, пользователь может выбрать, собственно, картинку, размер числа и способ получить это число из игровых данных.



------------


State - это регламентированное состояние игры. На данный момент считается, что все состояние игры описывается с помощью подобной структуры:

GameState {
  objects: GameObject[],
  players: Player[],
  attrs: Map (string -> u32),
}
GameObject {
  id: u32,
  templateId: u32,
  attrs: Map (string -> i32), 
}
Player {
  id: u32,
  attrs: Map (string -> i32), 
}


Ради простоты удобно считать, что мы ТОЛЬКО про карточки и называть GameObject'ы картами. Но надо понимать, что в нашем случае чем абстрактнее мы пишем, тем меньше потом пуль из ноги достаем, лучше сразу делать общо.

--------

Resources
Это самый простой в описании блок данных, некий манифест о том, какие бандлы/ресурсы надо скачивать для данной конкретной игры. Считается, что его в каком-то виде будет генерить админка. Юнити клиент должен уметь скачивать и кэшировать все необходимые ресусрсы.

  
--------

Клиент позволяет как-то взаимодействовать с виджетами - можно нажимать на кнопки, использовать карты. Когда юзер выполняет действие, которое касается игровой механики, клиент отправляет это действие (например, каст карты) в виде JSON на фронтенд. Тот преобразует это в транзакцию, подписывает ее с помощью юзера и отправляет в чейн. Когда чейн применит изменения к аккаунту игрового состояния, фронт получит изменения, сериализует игровое состояние в json и вызовет обновлении у юнити-фрейма




Рантайм для механики



GameState

GameObject {
  id: u32,
  templateId: u32,
  attrs: Map (string -> i32), 
}

GameContent {
  CardTypes
}


GameContent


GameContent